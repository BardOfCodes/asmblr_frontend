import React, { createContext, useContext, useCallback, useState } from 'react';

// Data that flows between components in a mode
export interface ModeData {
  shaderCode?: string;
  uniforms?: Record<string, any>;
  nodeGraph?: any;
  htmlContent?: string;
  viewerMode?: 'shader' | 'iframe';
  [key: string]: any;
}

// Actions that components can perform
export interface ModeActions {
  updateShaderCode: (code: string) => void;
  updateUniform: (name: string, value: any) => void;
  updateUniforms: (uniforms: Record<string, any>) => void;
  updateNodeGraph: (graph: any) => void;
  updateHtmlContent: (html: string) => void;
  setViewerMode: (mode: 'shader' | 'iframe') => void;
  generateShader: () => void;
  testIframe: () => Promise<void>;
  [key: string]: any;
}

export interface ModeContextValue {
  data: ModeData;
  actions: ModeActions;
}

const ModeContext = createContext<ModeContextValue | null>(null);

export const useModeContext = () => {
  const context = useContext(ModeContext);
  if (!context) {
    throw new Error('useModeContext must be used within a ModeProvider');
  }
  return context;
};

interface ModeProviderProps {
  children: React.ReactNode;
  onShaderGenerated?: (shaderCode: string) => void;
}

export const ModeProvider: React.FC<ModeProviderProps> = ({ 
  children, 
  onShaderGenerated 
}) => {
  const [data, setData] = useState<ModeData>({
    shaderCode: '',
    uniforms: {},
    nodeGraph: null,
    htmlContent: '',
    viewerMode: 'shader',
  });

  const updateShaderCode = useCallback((code: string) => {
    setData(prev => ({ ...prev, shaderCode: code }));
  }, []);

  const updateUniform = useCallback((name: string, value: any) => {
    setData(prev => ({
      ...prev,
      uniforms: { ...prev.uniforms, [name]: value }
    }));
  }, []);

  const updateUniforms = useCallback((uniforms: Record<string, any>) => {
    setData(prev => ({ ...prev, uniforms }));
  }, []);

  const updateNodeGraph = useCallback((graph: any) => {
    setData(prev => ({ ...prev, nodeGraph: graph }));
  }, []);

  const updateHtmlContent = useCallback((html: string) => {
    setData(prev => ({ ...prev, htmlContent: html }));
  }, []);

  const setViewerMode = useCallback((mode: 'shader' | 'iframe') => {
    setData(prev => ({ ...prev, viewerMode: mode }));
  }, []);

  const generateShader = useCallback(() => {
    // This will be implemented by each mode's specific logic
    console.log('Generating shader from node graph:', data.nodeGraph);
    if (onShaderGenerated && data.shaderCode) {
      onShaderGenerated(data.shaderCode);
    }
  }, [data.nodeGraph, data.shaderCode, onShaderGenerated]);

  const testIframe = useCallback(async () => {
    try {
      console.log('Fetching HTML from backend...');
      // TODO: Replace with actual backend endpoint
      const response = await fetch('/api/test-html', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (response.ok) {
        const htmlContent = await response.text();
        updateHtmlContent(htmlContent);
        setViewerMode('iframe');
        console.log('HTML loaded successfully');
      } else {
        // Fallback HTML for testing
        const fallbackHTML = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>Test HTML</title>
            <style>
              body { 
                font-family: 'Lato', sans-serif; 
                margin: 40px; 
                background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
                color: white;
                text-align: center;
              }
              .container {
                background: rgba(255,255,255,0.1);
                padding: 40px;
                border-radius: 10px;
                margin-top: 50px;
              }
              h1 { font-size: 2.5em; margin-bottom: 20px; }
              p { font-size: 1.2em; line-height: 1.6; }
              .timestamp { 
                font-size: 0.9em; 
                opacity: 0.8; 
                margin-top: 20px; 
              }
            </style>
          </head>
          <body>
            <div class="container">
              <h1>üöÄ Test HTML Content</h1>
              <p>This HTML was generated by the backend!</p>
              <p>The iframe viewer is working correctly.</p>
              <div class="timestamp">Generated at: ${new Date().toLocaleString()}</div>
            </div>
          </body>
          </html>
        `;
        updateHtmlContent(fallbackHTML);
        setViewerMode('iframe');
        console.log('Using fallback HTML content');
      }
    } catch (error) {
      console.error('Error fetching HTML from backend:', error);
      // Use fallback HTML
      const errorHTML = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>Error</title>
          <style>
            body { 
              font-family: 'Lato', sans-serif; 
              margin: 40px; 
              background: #ff6b6b;
              color: white;
              text-align: center;
            }
          </style>
        </head>
        <body>
          <h1>‚ö†Ô∏è Backend Connection Error</h1>
          <p>Could not fetch HTML from backend.</p>
          <p>Error: ${error instanceof Error ? error.message : 'Unknown error'}</p>
        </body>
        </html>
      `;
      updateHtmlContent(errorHTML);
      setViewerMode('iframe');
    }
  }, [updateHtmlContent, setViewerMode]);

  const actions: ModeActions = {
    updateShaderCode,
    updateUniform,
    updateUniforms,
    updateNodeGraph,
    updateHtmlContent,
    setViewerMode,
    generateShader,
    testIframe,
  };

  return (
    <ModeContext.Provider value={{ data, actions }}>
      {children}
    </ModeContext.Provider>
  );
};
